import os
import sqlite3
import pandas as pd
import streamlit as st
import openai
import io
import json
from dotenv import load_dotenv
from pathlib import Path
from api_connection import openai_message_creator, query_openai, schema_to_string, process_prompt_for_quarter_year
from schema_loader import load_schema
from pydantic import BaseModel, Field
from typing import List, Union, Optional, Tuple


class Background(BaseModel):
    """A setup to the background for the user."""
    background: str = Field(description="Background for the user's question", min_length=10)


class Thought(BaseModel):
    """A thought about the user's question."""
    thought: str  = Field(description="Text of the thought.")
    helpful: bool = Field(description="Whether the thought is helpful to solving the user's question.")


class Observation(BaseModel):
    """An observation on the sequence of thoughts and observations generated so far."""
    observation: str = Field(description="An insightful observation on the sequence of thoughts and observations generated so far.")
    

class Reasonings(BaseModel):
    """Returns a detailed reasoning to the user's question."""
    reasonings: list[Union[Background, Thought, Observation]] = Field(
        description="Reasonings to solve the users questions."
        #, min_length=5
    )

sample_reasonings=Reasonings(reasonings=[Background(background="The task is to generate SQL from natural language query."),
                                             Thought(thought="First thought", helpful="True"),
                                             Thought(thought="Second thought", helpful="True"),
                                             Thought(thought="Third thought", helpful="True"),
                                             Thought(thought="Fourth thought", helpful="True"),
                                             Thought(thought="Fifth thought", helpful="True"),
                                             Observation(observation="Astute observation")])

sample_reasonings.json()
reasonings_schema_json = Reasonings.schema_json()

class FinalQueryOutput(BaseModel):
    user_nlp_query: str = Field(
        description=f"""Returns the exact question that the user asked in natural language
        which is to be translated into SQL Query.""")
    reasonings: list[Union[Background, Thought, Observation]] = Field(
        description="Reasonings to solve the users questions."
        #, min_length=5
    )
    generated_sql_query: str = Field(
        description=f"""Returns the SQL Language Query corresponding to the
        NLP description of the user question.""")

final_output_schema_json = FinalQueryOutput.schema_json()


sample_output = FinalQueryOutput(user_nlp_query="Get count of rows.", 
                                 reasonings=[Background(background="Deadline is near"),
                                             Thought(thought="First thought", helpful="True"),
                                             Thought(thought="Second thought", helpful="True"),
                                             Thought(thought="Third thought", helpful="True"),
                                             Thought(thought="Fourth thought", helpful="True"),
                                             Thought(thought="Fifth thought", helpful="True"),
                                             Observation(observation="Astute observation")], 
                                 generated_sql_query="Select count * from fact_table")
sample_output.json()


# load env variables
load_dotenv()
API_KEY = os.getenv("OPENAI_API_KEY")
openai.api_key = API_KEY

# db path
db_path = Path("data/sec_nport_data_combined.db")

# Load the schema
schema_file_path = "data/data_schema2.txt"
schema = load_schema(schema_file_path)

# app title
st.title("PIMCO Bot")

# Example prompts and queries to guide chatbot behavior
example_prompts_and_queries = {
    "easy": [
        ...
    ],
    "medium": [
        ...
    ],
    "hard": [
        ...
    ]
}

# function to execute SQL query w debugging
def execute_sql_query(query, db_path):
    """
    Executes the provided SQL query against the SQLite database at db_path.
    Logs the query being executed for debugging purposes. If there's an error,
    it attempts to fix the query.
    """
    try:
        # Connect to the SQLite database
        conn = sqlite3.connect(db_path)

        # Debugging: Print the SQL query
        print(f"Executing Query:\n{query}")
        
        # Execute the query and fetch the result as a DataFrame
        df_result = pd.read_sql_query(query, conn)
        
        # Close the connection
        conn.close()
        
        return df_result
    except Exception as e:
        # Log the error
        print(f"Error executing the SQL query: {e}")
        # Generate the query-fixing prompt using the given details
        query_fixing_prompt = f"""
        **Task Description:**
        You are an SQL database expert tasked with correcting a SQL query. A previous attempt to run a query did not yield the correct results,
        either due to errors in execution or because the result returned was empty or unexpected. Your role is to analyze the error based on 
        the provided database schema and the details of the failed execution, and then provide a corrected version of the SQL query. 

        **Procedure:**
        1. Review Database Schema
        - Examine the following schema details to understand the database structure:
        {schema_to_string(schema)}
        2. Review Example User Questions, Queries, and Reasonings
        - Examine the following examples as a reference to guide your corrected response:
            - Easy Questions: {[example for example in example_prompts_and_queries['easy']]}
            - Medium Questions: {[example for example in example_prompts_and_queries['medium']]}
            - Hard Questions: {[example for example in example_prompts_and_queries['hard']]}
        3. Analyze Query Requirements:
        - Original Question: Consider what information the query is supposed to retrieve.
        - Executed SQL Query: Review the SQL query that was previously executed and led to an error or incorrect result.
        - Execution Result: Analyze the outcome of the executed query to identify why it failed (e.g., syntax errors, incorrect column references, logical mistakes).
        4. Adhere to Rules:
        - Remember the rules you must follow:
            - Only use `QUARTER` and `YEAR` in the SQL query, do not use any specific dates. If the user question contains a specific date, please convert this to the appropriate year and quarter.
            - Use a `LIKE` clause for partial matching of `ISSUER_NAME` (e.g., WHERE ISSUER_NAME LIKE '%value%').
            - All queries must be valid to access a SQLite database (e.g., use the command LIMIT instead of FETCH)\
            - Use "Y" and "N" instead of "YES" and "NO" in the SQL query (e.g., WHERE IS_DEFAULT = 'Y' instead of WHERE IS_DEFAULT = 'YES').
        5. Correct the Query:
        - Modify the SQL query to address the identified issues, ensuring it correctly fetches the requested data according to the database schema and query requirements.

        **Schema for Output:**
        - This includes the reasonings schema above as an element
        - The final response should be a json with `names` as `generated_sql_query` and `reasoning`:
            1. `generated_sql_query` should provide the SQL query generated in string format.
            2. `reasonings` should provide the reasoning steps adhering to the reasoning instructions.
        - This is the final answer.
        
        Based on the question, table schema, and previous query, analyze the result to fix the query and make it valid and executable.
        """
        
        # Query OpenAI to fix the query
        fixing_response = query_openai(openai_message_creator(
            user_message_string=query_fixing_prompt,
            system_message_string="You are an expert SQL assistant. Review the SQL query for errors and provide corrections with reasoning."
        ))
        
        if fixing_response:
            try: 
                # Parse the response to extract the suggested corrected query and reasoning
                response_json = json.loads(fixing_response)
                fixed_sql_query = response_json.get('generated_sql_query', '').strip()
                fixed_reasoning_list = response_json.get('reasonings', [])
                fixed_reasoning = "\n\n".join(f"- **{type(r).__name__}**: {r}" for r in reasoning_list)

                # Return the fixed query and reasoning
                return fixed_query, fixed_reasoning
            except json.JSONDecodeError:
                st.error("Error decoding response from OpenAI. Please try again.")

# function to validate SQL query
def validate_sql_query(query):
    """
    Validates that the SQL query is well-formed and safe to execute.
    """
    # Basic validation to check for SELECT and FROM statements
    if "SELECT" in query and "FROM" in query and ";" in query:
        return True
    return False

# display persistent query log
if "persistent_query_log" in st.session_state and st.session_state.persistent_query_log:
    for query_record in st.session_state.persistent_query_log:
        st.write("#### Question")
        st.markdown(query_record["question"])
        st.write("#### SQL Query")
        st.code(query_record["query"], language="sql")
        st.write("#### Reasoning")
        st.markdown(query_record["reasoning"])
        st.write("#### Results")
        st.dataframe(query_record["results"])

if "messages" not in st.session_state:
    st.session_state.messages = []

if "persistent_query_log" not in st.session_state:
    st.session_state.persistent_query_log = []

# user input
if prompt := st.chat_input("Enter your question about the database:"):
    # Add user message to chat history
    st.session_state.messages.append({"role": "user", "content": prompt})
    
    # Process specific dates or date ranges in the prompt
    refined_prompt = process_prompt_for_quarter_year(prompt)
    refined_prompt = f"Generate an SQL query for this request: '{refined_prompt}'. Return only the query and reasoning."

    # Generate OpenAI messages with schema and examples
    system_message_string = f"""
    **Task Description:**
    You are an assistant that generates SQL queries and their reasonings based on user questions related to the SEC N-PORT dataset. 
    N-PORT filings contain detailed reports submitted by registered investment companies, including mutual funds and exchange-traded funds (ETFs), which disclose their portfolio holdings on a monthly basis. 
    These filings provide transparency into the asset composition, performance, and risk exposures of these funds, offering valuable insights for investors, regulators, and researchers.
    Your goal is to write, explain, and execute SQL queries on a SQLite database to answer natural language questions asked by the user. 

    **Procedure**
    1. Review Database Schema
    - Examine the following schema details to understand the database structure:
    {schema_to_string(schema)}

    2. Review Example User Questions, Queries, and Reasonings
    - Examine the following examples as a reference to guide your response:
        - Easy Questions: {[example for example in example_prompts_and_queries['easy']]}
        - Medium Questions: {[example for example in example_prompts_and_queries['medium']]}
        - Hard Questions: {[example for example in example_prompts_and_queries['hard']]}

    3. Reasoning Instructions:
    - Provide a detailed, structured reasoning to justify the SQL query. This should include:
        1. **Background**: Describe any initial context or assumptions used to understand the problem.
        2. **Thought Process**: Break down the problem progressively:
            - Consider whether Common Table Expressions (CTEs) or subqueries are needed.
            - Identify which columns are relevant for the `select`, `where`, `group_by`, etc.
            - Determine potential values for `where` clauses, such as ISSUER_NAME, and map those to database columns.
            - Assess whether filters or aggregations are necessary.
            - Identify the time period and grouping conditions.
        3. **Observations**: Reflect on the reasoning steps, offer insights, and describe how the steps lead to the final query.
    - Think of this reasoning as the model describing the steps it took to create the query.
        1. Reasoning you provide should first focus on why a nested query was chosen or why it wasn't chosen.
        2. It should give a query plan on how to solve this question - explain the mapping of the columns to the words in the input question.
        3. It should explain each of the clauses and why they are structured the way they are structured. For example, if there is a `group_by`, an explanation should be given as to why it exists.
        4. If there's any sum() or any other function used it should be explained as to why it was required.
    
    **Rules:**
    1. Only use `QUARTER` and `YEAR` in the SQL query, do not use any specific dates. If the user question contains a specific date, please convert this to the appropriate year and quarter.
    2. Use a `LIKE` clause for partial matching of `ISSUER_NAME` (e.g., WHERE ISSUER_NAME LIKE '%value%').
    3. All queries must be valid to access a SQLite database (e.g., use the command LIMIT instead of FETCH)
    4. Use "Y" and "N" instead of "YES" and "NO" in the SQL query (e.g., WHERE IS_DEFAULT = 'Y' instead of WHERE IS_DEFAULT = 'YES').

    **Schema for Output:**
    - This includes the reasonings schema above as an element
    - The final response should be a json with `names` as `generated_sql_query` and `reasoning`:
        1. `generated_sql_query` should provide the SQL query generated in string format.
        2. `reasonings` should provide the reasoning steps adhering to the reasoning instructions.
    - This is the final answer.
    """
    messages = openai_message_creator(user_message_string=refined_prompt, system_message_string=system_message_string, schema=schema)

    response = query_openai(messages)

    if response:
        # Assuming response is a well-formed JSON string from OpenAI, parse it
        try:
            response_json = json.loads(response)
            # Extract the generated SQL query and reasoning
            generated_sql_query = response_json.get('generated_sql_query', '').strip()
            reasoning_list = response_json.get('reasonings', [])
            reasoning = "\n\n".join(f"- **{type(r).__name__}**: {r}" for r in reasoning_list)
            
            # Clean the SQL query before executing it
            cleaned_sql_query = generated_sql_query.replace("```sql", "").replace("```", "").strip()

            print(f"Cleaned SQL Query:\n{cleaned_sql_query}")
            print(f"Reasoning:\n{reasoning}")
            
            # Validate the cleaned query
            if validate_sql_query(cleaned_sql_query):
                # Execute the cleaned query
                df_result = execute_sql_query(cleaned_sql_query, db_path)
                
                if df_result is not None:
                    # Save query, reasoning, and results to persistent query log
                    query_record = {
                        "question": prompt,
                        "query": cleaned_sql_query,
                        "reasoning": reasoning,
                        "results": df_result
                    }
                    st.session_state.persistent_query_log.append(query_record)

                    # Display SQL query, reasoning, and results
                    st.write("#### Question")
                    st.markdown(query_record["question"])
                    st.write("#### SQL Query")
                    st.code(query_record["query"], language="sql")
                    st.write("#### Reasoning")
                    st.markdown(query_record["reasoning"])
                    st.write("#### Results")
                    st.dataframe(query_record["results"])

                    # Convert the DataFrame to CSV format
                    csv = df_result.to_csv(index=False)

                    # Create a downloadable CSV file 
                    st.download_button(
                        label="Download results as CSV",
                        data=csv,
                        file_name="query_results.csv",
                        mime="text/csv"
                    )
                else:
                    st.error("Failed to execute the query. Check the logs for details.")
            else:
                # If the query is invalid, show an error message
                st.error("Invalid SQL query generated. Please review.")
        except json.JSONDecodeError:
            st.error("Error decoding response from OpenAI. Please try again.")






# {
#             "question": " ",
#             "query": """
            
#             """,
#             "reasoning": """
            
#             """,
#             "schema_links": " "
#         }
