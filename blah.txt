import os
import sqlite3
import pandas as pd
import openai
import json
import textwrap
from dotenv import load_dotenv
from pathlib import Path
from api_connection import (
    openai_message_creator,
    query_openai,
    schema_to_string,
    process_prompt_for_quarter_year
)
from schema_loader import load_schema
from pydantic import BaseModel, Field
from typing import List, Union, Optional, Tuple

__all__ = [
    "execute_sql_query",
    "validate_sql_query",
    "process_prompt_for_quarter_year",
    "query_openai",
    "openai_message_creator",
    "generate_system_message",
    "schema",
    "example_prompts_and_queries"
]

# Load Environment Variables
load_dotenv()
API_KEY = os.getenv("OPENAI_API_KEY")
openai.api_key = API_KEY

# Database Path
db_path = Path("data/sec_nport_data_combined.db")

# Load the Schema
schema_file_path = "data/data_schema2.txt"
schema = load_schema(schema_file_path)
key_schema_file_path = "data/key_schema.txt"
key_schema = load_schema(key_schema_file_path)


# Pydantic Models
class Background(BaseModel):
    """A setup to the background for the user."""
    background: str = Field(description="Background for the user's question", min_length=10)

class Thought(BaseModel):
    """A thought about the user's question."""
    thought: str = Field(description="Text of the thought.")
    helpful: bool = Field(description="Whether the thought is helpful to solving the user's question.")

class Observation(BaseModel):
    """An observation on the sequence of thoughts and observations generated so far."""
    observation: str = Field(description="An insightful observation on the sequence of thoughts and observations generated so far.")

class Reasonings(BaseModel):
    """Returns a detailed reasoning to the user's question."""
    reasonings: list[Union[Background, Thought, Observation]] = Field(
        description="Reasonings to solve the users questions."
    )

sample_reasonings = Reasonings(reasonings=[
    Background(background="The task is to generate SQL from natural language query."),
    Thought(thought="First thought", helpful=True),
    Thought(thought="Second thought", helpful=True),
    Thought(thought="Third thought", helpful=True),
    Thought(thought="Fourth thought", helpful=True),
    Thought(thought="Fifth thought", helpful=True),
    Observation(observation="Astute observation")
])

sample_reasonings.json()

reasonings_schema_json = Reasonings.schema_json()

class FinalQueryOutput(BaseModel):
    user_nlp_query: str = Field(
        description=f"""Returns the exact question that the user asked in natural language
        which is to be translated into SQL Query."""
    )
    reasonings: list[Union[Background, Thought, Observation]] = Field(
        description="Reasonings to solve the users questions."
    )
    generated_sql_query: str = Field(
        description=f"""Returns the SQL Language Query corresponding to the
        NLP description of the user question."""
    )

final_output_schema_json = FinalQueryOutput.schema_json()

sample_output = FinalQueryOutput(
    user_nlp_query="Get count of rows.",
    reasonings=[
        Background(background="Deadline is near"),
        Thought(thought="First thought", helpful=True),
        Thought(thought="Second thought", helpful=True),
        Thought(thought="Third thought", helpful=True),
        Thought(thought="Fourth thought", helpful=True),
        Thought(thought="Fifth thought", helpful=True),
        Observation(observation="Astute observation")
    ],
    generated_sql_query="SELECT COUNT(*) FROM fact_table"
)

sample_output.json()

# System Prompts
system_prompt_snippet_001 = """
You are the most intelligent person in the world.
"""
system_prompt_snippet_002 = """
You will receive a $500 tip if you follow ALL the instructions specified.
"""
system_prompt_snippet_003 = """
Use step by step reasoning and at each step generate thoughts of increasing complexity.
"""
system_prompt_snippet_004 = """
Getting this answer right is important for my career. Please do your best.
"""
system_prompt = f"""
{system_prompt_snippet_001}
{system_prompt_snippet_002}
{system_prompt_snippet_003}
{system_prompt_snippet_004}
"""

def generate_system_message() -> str:
    """
    Generates the system message by combining predefined snippets.
    """
    return system_prompt


# Example Prompts and Queries
example_prompts_and_queries = {
    ...
}

# User Prompt Generation
def get_user_prompt_for_question(input_question: str) -> str:
    """
    Generates the complete user prompt for OpenAI based on the current schema and examples.
    """
    complete_user_prompts = textwrap.dedent(f"""
    **Task Description**
    You are an assistant that generates SQL queries and their reasonings based on user questions related to the SEC N-PORT dataset. 

    **N-PORT Dataset Overview**
    N-PORT filings contain detailed reports submitted by registered investment companies, including mutual funds and exchange-traded funds (ETFs), which disclose their portfolio holdings on a monthly basis. 
    These filings provide transparency into the asset composition, performance, and risk exposures of these funds, offering valuable insights for investors, regulators, and researchers.

    Your goal is to write, explain, and execute SQL queries on a SQLite database to answer natural language questions asked by the user. 

    **Database Schema Description**
    Examine the following schema details to understand the database structure:
    {schema}
    
    Examine the following key schema that identifies the primary keys for each table in the database:
    {key_schema}

    **Example Natural Language Questions and Their Corresponding SQL Queries and Reasonings**
    Examine the following examples as a reference to guide your response:
    - Easy Questions: {[example for example in example_prompts_and_queries['easy']]}
    - Medium Questions: {[example for example in example_prompts_and_queries['medium']]}
    - Hard Questions: {[example for example in example_prompts_and_queries['hard']]}

    **Rules for SQL Query Generation**
    - Only use `QUARTER` and `YEAR` in the SQL query, do not use any specific dates. If the user question contains a specific date, please convert this to the appropriate year and quarter.
    - Use a `LIKE` clause for partial matching of `ISSUER_NAME` (e.g., WHERE ISSUER_NAME LIKE '%value%').
    - All queries must be valid to access a SQLite database (e.g., use the command LIMIT instead of FETCH)
    - Use "Y" and "N" instead of "YES" and "NO" in the SQL query (e.g., WHERE IS_DEFAULT = 'Y' instead of WHERE IS_DEFAULT = 'YES').
    - Use the key schema to identify the primary keys for each table in the database. If you need to join two tables that do not have the same primary key, find an intermidiate table that has both primary keys.
    """)

    user_prompt = textwrap.dedent(f"""
    Here's the question that the user entered:
    {input_question}

    Generate a SQL query corresponding to the given input question and the description of the table provided below.
    {complete_user_prompts}

    Reasoning as to why the query is correct:
    {reasoning_instructions}
    {reasoning_schema_instructions}

    Response for SQL Generation:
    """)
    
    return user_prompt


# Reasoning Instructions
reasoning_instructions = """
1. Reasoning you provide should first focus on why a nested query was chosen or why it wasn't chosen.
2. It should give a query plan on how to solve this question - explain 
the mapping of the columns to the words in the input question.
3. It should explain each of the clauses and why they are structured the way they are structured. 
For example, if there is a `group_by`, an explanation should be given as to why it exists.
4. If there's any sum() or any other function used it should be explained as to why it was required.

Format the generated sql with proper indentation - the columns in the (`select` statement should have more indentation than keyword `select` and so on for each SQL clause.)
"""  

# Thought Instructions
thought_instructions = f"""

Thought Instructions:

Generate thoughts of increasing complexity.
Each thought should build on the previous ones and thoughts should progressively cover the nuances of the problem at hand.

First set of thoughts should be on whether a the query requires Common Table Expressions (CTEs) to calculate the results for sub queries. 
- Prefer using Common Table Expressions rather than case when statements or nested subqueries.
- If CTEs are required then for each CTE, an analysis of the purpose of each CTE should be done.
- An overall structure should be outlined as to what will be calculated in each CTE.

Next set of thoughts should be on deciding the relevant tables that should be used for the query.
- For each table, one set of thoughts should be to summarize their primary and secondary keys.
- A list of columns that should be extracted from them should be mentioned.
- This list should be checked against the list of columns present in the table which is mentioned in the schema description provided earlier.

Next set of thoughts should be to figure out the joins that need to be usedin the query.
- A justification for using left, right or inner join should be provided.

Next set of thoughts should be on extracting out the names of as many of the relevant columns as possible for all CTEs and for all the sql clauses such as the 
`select`, `where` and `group_by` clauses.
- There might be additions or deletions from this list based on the following additional thoughts to be generated.

Generate a thought to figure out the possible phrases in the query which can be used as values of the columns present in the table so as to use them in the `where` clause.

Generate a thought to compare these extracted values with the list of possible values of columns listed in the information for the columns so as to use the exact string in the `where` clause.

The above thoughts about 
    1. phrases for values of columns
    2. query phrase to column value mapping
    3. Group by column
should be generated for each of the CTE separately.

If the input question is similar to any of the examples given above, then a thought should be generated to detect that and then that example should be followed closely to get the SQL for the input question given.

Closing Thoughts and Observations
    These should summarize:
    1. The structure of the SQL query:
        - This states whether the query has any nested query.
        If so, the structure of the nested query is also mentioned.
        If not, a summary of the function of each of the select`, `where`, `group_by` etc. clauses should be mentioned.
    2. An explanation of how the query solves the user question.
"""


reasoning_schema_instructions = f"""
Use the following JSON Schema as the grammar to create the structure for the step by step reasoning, and then to create the final SQL query.

Schema for Reasoning:
{reasonings_schema_json}

The instructions on how to structure the reasoning is provided below:
{thought_instructions}

Schema for Overall Output: (This includes the reasonings schema above as an element)
{final_output_schema_json}

The final response should be a json with `names` as `user_nlp_query`, `reasonings`, and `generated_sql_query`:
1. `user_nlp_query` should be exactly the same as the user query in string format.
2. `reasonings` should provide the reasoning steps adhering to the Reasonings schema.
3. `generated_sql_schema` should provide the SQL query generated in string format.
- this is the final answer.
"""

def execute_sql_query(query: str, db_path: Path, input_question: str, max_attempts: int = 3) -> Optional[pd.DataFrame]:
    """
    Executes the provided SQL query against the SQLite database at db_path.
    If there's an error, tries to fix the query using OpenAI up to `max_attempts` times.
    After the third failed attempt, displays an error message and returns None.
    """

    attempt = 1
    current_query = query

    while attempt <= max_attempts:
        try:
            # Connect to the SQLite database
            conn = sqlite3.connect(db_path)

            # Debugging: Print the SQL query
            print(f"Attempt {attempt}: Executing Query:\n{current_query}")
            
            # Execute the query and fetch the result as a DataFrame
            df_result = pd.read_sql_query(current_query, conn)
            
            # Close the connection
            conn.close()

            # If successful, return the DataFrame
            return df_result

        except Exception as e:
            # Log the error
            print(f"Error executing the SQL query on attempt {attempt}: {e}")

            # If this was the last attempt, give up and return None
            if attempt == max_attempts:
                print("Max attempts reached. Could not fix the query.")
                return None

            # Otherwise, attempt to fix the query
            query_fixing_prompt = textwrap.dedent(f"""
            **Task Description:**
            You are an SQL database expert tasked with correcting a SQL query. A previous attempt to run a query did not yield the correct results,
            either due to errors in execution or because the result returned was empty or unexpected. Your role is to analyze the error based on 
            the provided database schema and the details of the failed execution, and then provide a corrected version of the SQL query. 

            **Procedure:**
            1. Review Database Schema
            - Examine the following schema details to understand the database structure:
            {schema}
            - Examine the following key schema that identifies the primary keys for each table in the database:
            {key_schema}

            2. Review Example User Questions, Queries, and Reasonings
            - Examine the following examples as a reference to guide your corrected response:
                - Easy Questions: {[example for example in example_prompts_and_queries['easy']]}
                - Medium Questions: {[example for example in example_prompts_and_queries['medium']]}
                - Hard Questions: {[example for example in example_prompts_and_queries['hard']]}

            3. Analyze Query Requirements:
            - Original Question: Consider what information the query is supposed to retrieve.
              Here's the question that the user entered: {input_question}

            - Executed SQL Query: Review the SQL query that was previously executed and led to an error:
              {current_query}

            - Execution Result: Analyze why it may have failed (e.g., syntax errors, incorrect column references, logical mistakes).

            4. Review Reasoning Instructions:
            {reasoning_instructions}
            {reasoning_schema_instructions}

            5. Adhere to Rules:
            - Only use `QUARTER` and `YEAR` in the SQL query, do not use any specific dates. If the user question contains a specific date, please convert this to the appropriate year and quarter.
            - Use a `LIKE` clause for partial matching of `ISSUER_NAME` (e.g., WHERE ISSUER_NAME LIKE '%value%').
            - All queries must be valid to access a SQLite database (e.g., use the command LIMIT instead of FETCH)
            - Use "Y" and "N" instead of "YES" and "NO" in the SQL query (e.g., WHERE IS_DEFAULT = 'Y' instead of WHERE IS_DEFAULT = 'YES').
            - Use the key schema to identify the primary keys for each table in the database. If you need to join two tables that do not have the same primary key, find an intermediate table that has both primary keys.

            6. Correct the Query and Corresponding Reasoning:
            - Modify the SQL query to address the identified issues, ensuring it correctly fetches the requested data according to the database schema and query requirements.
            - Return the final JSON response as per the schema instructions provided earlier.
            """)

            fixing_response = query_openai(openai_message_creator(
                user_message_string=query_fixing_prompt,
                system_message_string="You are an expert SQL assistant. Review the SQL query for errors and provide corrections with reasoning."
            ))

            if fixing_response:
                try: 
                    # Parse the response to extract the suggested corrected query and reasoning
                    response_json = json.loads(fixing_response)
                    fixed_sql_query = response_json.get('generated_sql_query', '').strip()

                    if fixed_sql_query:
                        # Update current_query with the fixed query and try again
                        current_query = fixed_sql_query
                    else:
                        # If no fixed query was provided, we can't proceed
                        print("No fixed SQL query returned by OpenAI.")
                        return None

                except json.JSONDecodeError:
                    print("Error decoding response from OpenAI. Please try again.")
                    return None
            else:
                print("No response from OpenAI when attempting to fix the query.")
                return None

        attempt += 1

    # If we exit the loop without returning, no luck fixing or executing the query
    print("Max attempts reached. Could not fix the query.")
    return None

def validate_sql_query(query: str) -> bool:
    """
    Validates that the SQL query is well-formed and safe to execute.
    """
    # Basic validation to check for SELECT and FROM statements
    if "SELECT" in query.upper() and "FROM" in query.upper() and ";" in query:
        return True
    return False







